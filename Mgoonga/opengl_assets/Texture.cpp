#include "stdafx.h"
#include "Texture.h"

#include <glm/glm/gtc/noise.hpp>

#include "TextureImplDevIl.h"
#include "TextureImplSDL.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#include <math/Random.h>

unsigned int Texture::textures_in_use = 0;
std::set<unsigned int> Texture::indexes_in_use = {};
GLuint Texture::mg_default_texture_id = (GLuint)glm::pow(2, 32) - 1;
GLuint Texture::mg_empty_texture_id = (GLuint)glm::pow(2, 32) - 1;

//-----------------------------------------------
GLuint Texture::GetDefaultTextureId()
{
	return mg_default_texture_id;
}

//-----------------------------------------------
void Texture::SetEmptyTextureId(GLuint _default_id)
{
	mg_empty_texture_id = _default_id;
}

//-----------------------------------------------
GLuint Texture::GetEmptyTextureId()
{
	return mg_empty_texture_id;
}

//-----------------------------------------------
Texture Texture::GetTexture1x1(TColor color)
{
	static Texture white;
	static Texture black;
	static Texture blue;
	static Texture pink;
	static Texture yellow;
	static Texture grey;

	if (white.id == GetDefaultTextureId())
		white._loadTexture1x1(WHITE);
	if (black.id == GetDefaultTextureId())
		black._loadTexture1x1(BLACK);
	if (blue.id == GetDefaultTextureId())
		blue._loadTexture1x1(BLUE);
	if (pink.id == GetDefaultTextureId())
		pink._loadTexture1x1(PINK);
	if (yellow.id == GetDefaultTextureId())
		yellow._loadTexture1x1(YELLOW);
	if (grey.id == GetDefaultTextureId())
		grey._loadTexture1x1(GREY);

	switch (color)
	{
		case WHITE: return white;
		case BLACK: return black;
		case BLUE: return blue;
		case PINK: return pink;
		case YELLOW: return yellow;
		case GREY: return grey;
	}
	assert("unknown color in Texture!");
}

bool Texture::freeTexture(unsigned int _id)
{
	//Delete texture
	if (_id != 0)
	{
		if (indexes_in_use.find(_id) != indexes_in_use.end())
		{
			std::cout << "free texture " << _id << ": " << --textures_in_use << std::endl;
			indexes_in_use.erase(_id);
			glDeleteTextures(1, &_id);
			return true;
		}
		else
		{
			std::cout << "trying to free texture which was not generated by texture class" << std::endl;
		}
	}
	return false;
}

Texture::Texture()
{
	type = "default";
	path = "empty";
	id = GetDefaultTextureId();
	mTextureWidth = 1, mTextureHeight = 1;
	mChannels = 4;
	//loadTexture1x1(YELLOW);
}

Texture::~Texture()
{
}

Texture::Texture(GLuint Width, GLuint Height, int32_t TextureChannels)
	:Texture()
{
	mTextureWidth = Width;
	mTextureHeight = Height;
	mChannels = TextureChannels;
}

Texture::Texture(GLuint ID, GLuint TextureWidth, GLuint TextureHeight, int32_t TextureChannels)
	:id(ID), mTextureWidth(TextureWidth), mTextureHeight(TextureHeight), mChannels(TextureChannels)
{}

bool Texture::loadTextureFromFile(const std::string& _path, GLenum format, GLenum wrap)
{
	path		= _path;
	uint32_t ilId;
	mChannels = eTextureImplDevIl::LoadTexture(path, ilId, mTextureWidth, mTextureHeight);
	uint8_t* data = nullptr;
	eTextureImplDevIl::AssignPixels(data, mTextureWidth, mTextureHeight);

	// Load textures
	_genTexture();
	glBindTexture(GL_TEXTURE_2D, id);
	glTexImage2D(GL_TEXTURE_2D,
				0, 
				mChannels == 4 ? GL_RGBA : GL_RGB,
				mTextureWidth, 
				mTextureHeight, 
				0, 
				mChannels == 4 ? GL_RGBA : GL_RGB,
				GL_UNSIGNED_BYTE,
				(GLubyte*)data);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	if (type == "terrain")
		glGenerateMipmap(id);

	eTextureImplDevIl::DeleteImage(ilId);
	return true;
}

uint8_t* Texture::getPixelBuffer(GLenum _target, GLenum _format, GLenum _type)
{ 
	int sizeOfByte = /*_format == GL_FLOAT ? sizeof(float) :*/ sizeof(unsigned char);
	int bytesToUsePerPixel = mChannels;
	int theSize = mTextureWidth * mTextureHeight * sizeOfByte * bytesToUsePerPixel;
	uint8_t* imData = (uint8_t*)malloc(theSize);

	glBindTexture(GL_TEXTURE_2D, this->id);
	glGetTexImage(_target, 0, _format, _type, (void*)imData); //generic
	glBindTexture(GL_TEXTURE_2D, 0);
	return imData;
}

bool Texture::saveToFile(const std::string &path, GLenum _target, GLenum _format, GLenum _type)
{
	uint8_t* imData = getPixelBuffer(_target, _format, _type);
	eTextureImplDevIl::SaveToFile(imData, path, mTextureWidth, mTextureHeight, mChannels); //rgb/rgba byte/float ?
	free(imData);
	return true;
}

void Texture::freeTexture()
{
	//Delete texture
	if (id != 0)
	{
		if (indexes_in_use.find(id) != indexes_in_use.end())
		{
			std::cout << "free texture " << id << ": " << --textures_in_use << std::endl;
			indexes_in_use.erase(id);
			glDeleteTextures(1, &id);
			id = 0;
		}
		else
		{
			std::cout << "trying to free texture which was not generated by texture class" << std::endl;
		}
	}
	mTextureWidth = 0;
	mTextureHeight = 0;
}

bool Texture::_loadTexture1x1(TColor color)
{
	GLubyte tex[4];
	switch (color)
	{
	case WHITE:
		tex[0]=255, tex[1] = 255, tex[2] = 255, tex[3] = 255;
		break;
	case BLACK:
		tex[0] = 0, tex[1] = 0, tex[2] = 0, tex[3] = 255;
		break;
	case BLUE:
		tex[0] = 128, tex[1] = 128, tex[2] = 255, tex[3] = 255;
		break;
	case PINK:
		tex[0] = 232, tex[1] = 100, tex[2] = 214, tex[3] = 255;
		break;
	case YELLOW:
		tex[0] = 255, tex[1] = 255, tex[2] = 0, tex[3] = 255;
		break;
	case GREY:
		tex[0] = 122, tex[1] = 122, tex[2] = 122, tex[3] = 255;
		break;
	}
	// Load textures
	_genTexture();
	glBindTexture(GL_TEXTURE_2D, id);

	mTextureWidth = 1;
	mTextureHeight = 1;
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mTextureWidth, mTextureHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, tex);
	mChannels = 4;

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glBindTexture(GL_TEXTURE_2D, 0);
	
	return true;
}

bool Texture::loadCubemap(std::vector<std::string> faces)
{
  //unsigned char* image;
  _genTexture();
  glBindTexture(GL_TEXTURE_CUBE_MAP, id);
  for (GLuint i = 0; i < faces.size(); i++)
  {
    //	glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, Width, Height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
    //Generate and set current image ID
    ILuint imgID = 0;
    ilGenImages(1, &imgID);
    ilBindImage(imgID);

    //Load image
    //ILboolean success = ilLoadImage( path.c_str() );
    ILboolean success = ilLoadImage((const wchar_t*)(faces[i].c_str)());
    int i0 = ilGetError();
    if (!success)
      std::cout << "error loading image" << std::endl;
    int i1 = IL_COULD_NOT_OPEN_FILE;
    int i2 = IL_ILLEGAL_OPERATION;
    int i3 = IL_INVALID_PARAM;
    //Image loaded successfully
    mTextureWidth = ilGetInteger(IL_IMAGE_WIDTH);
    mTextureHeight = ilGetInteger(IL_IMAGE_HEIGHT);
    auto pixmap = new BYTE[mTextureWidth * mTextureHeight * 3];
    ilCopyPixels(0, 0, 0, mTextureWidth, mTextureHeight, 1, IL_RGB, IL_UNSIGNED_BYTE, pixmap);
    //Convert image to RGBA
    success = ilConvertImage(IL_RGBA, IL_UNSIGNED_BYTE);
    if (!success)
      std::cout << "error converting image" << std::endl;
    // Load textures
    glBindTexture(GL_TEXTURE_2D, id);
    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGBA, mTextureWidth, mTextureHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, (GLuint*)ilGetData());
    //
    ilDeleteImages(1, &imgID);
		delete[] pixmap;
  }
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
  glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
  mChannels = 4; // 3?

  return true;
}

//----------------------------------------------------------------------------------------------------------
bool Texture::makeCubemap(size_t _size, bool _mipmap, GLenum _format, GLenum _internal_format, GLenum _type)
{
	//@todo customize - channels
	mChannels = 3;
	mTextureWidth = (int32_t)_size;
	mTextureHeight = (int32_t)_size;

	_genTexture();
	glBindTexture(GL_TEXTURE_CUBE_MAP, id);

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
	if(_mipmap)
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	else
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	int buffer_size = mTextureWidth * mTextureHeight * mChannels;

	for (GLuint i = 0; i < 6; ++i)
	{
		std::vector<float> xData(buffer_size, 0.2f + i * 0.2f); //for debug
		glBindTexture(GL_TEXTURE_2D, id);
		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, _internal_format, mTextureWidth, mTextureHeight, 0, _format, _type, &xData[0]);
	}
	if(_mipmap)
		glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

	glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
	return true;
}

bool Texture::makeDepthTexture()
{
	assert(mTextureHeight);
	assert(mTextureWidth);

	_genTexture();
	glBindTexture(GL_TEXTURE_2D, id);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, mTextureWidth, mTextureHeight, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE);
	GLfloat borderColor[] = { 1.0,  1.0,  1.0,  1.0 };
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER);

	return true;
}

bool Texture::makeDepthCubeMap()
{
	assert(mTextureHeight);
	assert(mTextureWidth);

	_genTexture();
	glBindTexture(GL_TEXTURE_CUBE_MAP, id);
	for (unsigned int i = 0; i < 6; ++i)
		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_DEPTH_COMPONENT,
			mTextureWidth, mTextureHeight, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

	return true;
}

bool Texture::makeRandom1DTexture(unsigned int _size)
{
	glm::vec3* pRandomData = new glm::vec3[_size];

	for (unsigned int i = 0; i < _size; i++)
	{
		pRandomData[i].x = math::Random::RandomFloat(0.0f, 1.0f);
		pRandomData[i].y = math::Random::RandomFloat(0.0f, 1.0f);
		pRandomData[i].z = math::Random::RandomFloat(0.0f, 1.0f);
	}

	_genTexture();
	glBindTexture(GL_TEXTURE_1D, id);
	glTexImage1D(GL_TEXTURE_1D, 0, GL_RGB, _size, 0, GL_RGB, GL_FLOAT, pRandomData);//?
	glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	delete[] pRandomData;

	return true;
}

bool Texture::generatePerlin(GLuint _width, GLuint _height, bool periodic)
{
	this->mTextureWidth = _width;
	this->mTextureHeight = _height;

	float a = 1.0f;
	float b = 2.0f;

	float xFactor = 1.0f / (_width - 1);
	float yFactor = 1.0f / (_height - 1);

	this->mChannels = 4; //octaves

	GLubyte *data = new GLubyte[_width * _height * 4];
	for (uint32_t row = 0; row < _height; row++)
	{
		for (uint32_t col = 0; col < _width; col++)  //row?
		{
			float x = xFactor * col;
			float y = yFactor * row;
			float sum = 0.0f;
			float freq = a;
			float scale = b;
			for (int oct = 0; oct < mChannels; ++oct)
			{
				glm::vec2 p(x * freq, y * freq);
				float val = 0.0f;
				if(periodic)
					val = glm::perlin(p, glm::vec2(freq) ) / scale;
				else
					val = glm::perlin(p) / scale;

				sum += val;
				float result = (sum + 1.0f) / 2.0f;

				data[((row * _width + col) * 4) + oct] = (GLubyte)(result * 255.0f);
				freq *= 2.0f;
				scale *= b;
			}
		}
	}
	
	_genTexture();
	glBindTexture(GL_TEXTURE_2D, id);
	glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, this->mTextureWidth, this->mTextureHeight);
	glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, this->mTextureWidth, this->mTextureHeight, GL_RGBA, GL_UNSIGNED_BYTE, (void*)data);
	
	delete[] data;
	return true;
}

bool Texture::loadHdr(const std::string& _path)
{
	stbi_set_flip_vertically_on_load(true);
	path = _path;
	float* data = stbi_loadf(_path.c_str(), &mTextureWidth, &mTextureHeight, &mChannels, 0);
	if (data)
	{
		_genTexture();
		glBindTexture(GL_TEXTURE_2D, id);
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, mTextureWidth, mTextureHeight, 0, GL_RGB, GL_FLOAT, data);

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		stbi_image_free(data);
		return true;
	}
	else
	{
		std::cout << "Failed to load HDR image." << std::endl;
		return false;
	}
}

//----------------------------------------------------------------------
bool Texture::loadTexture2DArray(std::vector<std::string> _paths)
{
	path = "";
	type = "";
	mTextureWidth = 512; //?
	mTextureHeight = 512;
	GLsizei layers = (GLsizei)_paths.size();
	glCreateTextures(GL_TEXTURE_2D_ARRAY, 1, &id);
	++textures_in_use;
	indexes_in_use.insert(id);
	glTextureStorage3D(id, 1, GL_RGBA8, mTextureWidth, mTextureHeight, layers);

	uint32_t ilId;
	for (int layer = 0; layer < _paths.size(); ++layer)
	{
		mChannels = eTextureImplDevIl::LoadTexture(_paths[layer], ilId, mTextureWidth, mTextureHeight); //rgb ? rgba
		uint8_t* data = nullptr;
		eTextureImplDevIl::AssignPixels(data, mTextureWidth, mTextureHeight);
		glTextureSubImage3D(id, 0/*mipmap_level*/, 0/*offset.x*/, 0/*offset.y*/, layer/*offset.z*/, mTextureWidth, mTextureHeight, 1 /*layer*/, GL_RGBA, GL_UNSIGNED_BYTE, data);
		eTextureImplDevIl::DeleteImage(ilId);
	}

	glTextureParameteri(id, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTextureParameteri(id, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTextureParameteri(id, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTextureParameteri(id, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	return true;
}

//----------------------------------------------------------------------
void Texture::_genTexture()
{
	glGenTextures(1, &id);
	if (id != GetDefaultTextureId())
	{
		std::cout << "gen texture " << id << std::endl;
		++textures_in_use;
		indexes_in_use.insert(id);
	}
}
