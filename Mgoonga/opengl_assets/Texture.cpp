#include "stdafx.h"
#include "Texture.h"

#include <glm/glm/gtc/noise.hpp>

#include "TextureImplDevIl.h"
//#include "TextureImplSDL.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#include <math/Random.h>

unsigned int Texture::textures_in_use = 0;
std::set<unsigned int> Texture::indexes_in_use = {};
GLuint Texture::mg_default_texture_id = (GLuint)glm::pow(2, 32) - 1;
GLuint Texture::mg_empty_texture_id = (GLuint)glm::pow(2, 32) - 1;
bool Texture::m_use_mipmaps = true;

//-----------------------------------------------
GLuint Texture::GetDefaultTextureId()
{
	return mg_default_texture_id;
}

//-----------------------------------------------
void Texture::SetEmptyTextureId(GLuint _default_id)
{
	mg_empty_texture_id = _default_id;
}

//-----------------------------------------------
GLuint Texture::GetEmptyTextureId()
{
	return mg_empty_texture_id;
}

//-----------------------------------------------
Texture Texture::GetTexture1x1(TColor color)
{
	static Texture white;
	static Texture black;
	static Texture blue;
	static Texture pink;
	static Texture yellow;
	static Texture grey;

	if (white.m_id == GetDefaultTextureId())
		white._loadTexture1x1(WHITE);
	if (black.m_id == GetDefaultTextureId())
		black._loadTexture1x1(BLACK);
	if (blue.m_id == GetDefaultTextureId())
		blue._loadTexture1x1(BLUE);
	if (pink.m_id == GetDefaultTextureId())
		pink._loadTexture1x1(PINK);
	if (yellow.m_id == GetDefaultTextureId())
		yellow._loadTexture1x1(YELLOW);
	if (grey.m_id == GetDefaultTextureId())
		grey._loadTexture1x1(GREY);

	switch (color)
	{
		case WHITE: return white;
		case BLACK: return black;
		case BLUE: return blue;
		case PINK: return pink;
		case YELLOW: return yellow;
		case GREY: return grey;
	}
	assert("unknown color in Texture!");
	throw;
	return {};
}

//-----------------------------------------------------------------------------------------------
Texture::Texture(GLuint Width, GLuint Height, int32_t TextureChannels)
	: Texture()
{
	m_width = Width;
	m_height = Height;
	m_channels = TextureChannels;
}

//-----------------------------------------------------------------------------------------------
Texture::Texture(GLuint ID, GLuint TextureWidth, GLuint TextureHeight, int32_t TextureChannels)
	:m_id(ID), m_width(TextureWidth), m_height(TextureHeight), m_channels(TextureChannels)
{}

//-----------------------------------------------------------------------------------------------
Texture::Texture()
	: m_type("default"), m_path("empty"), m_id(GetDefaultTextureId()), m_width(1), m_height(1), m_channels(4)
{
}

//-----------------------------------------------------------------------------------------------
Texture::Texture(const TextureInfo& _info)
	:m_type(_info.m_type), m_path(_info.m_path), m_id(GetDefaultTextureId())
{
}

//-----------------------------------------------------------------------------------------------
bool Texture::freeTexture(unsigned int _id)
{
	//Delete texture
	if (_id != 0)
	{
		if (indexes_in_use.find(_id) != indexes_in_use.end())
		{
			std::cout << "free texture " << _id << ": " << --textures_in_use << std::endl;
			indexes_in_use.erase(_id);
			glDeleteTextures(1, &_id);
			return true;
		}
		else
		{
			std::cout << "trying to free texture which was not generated by texture class" << std::endl;
		}
	}
	return false;
}

//-----------------------------------------------------------------------------------------------
Texture::~Texture()
{
}

//-----------------------------------------------------------------------------------------------
bool Texture::loadTextureFromFile(const std::string& _path, GLenum format, GLenum wrap)
{
	m_path		= _path;
	uint32_t ilId;
	m_channels = eTextureImplDevIl::LoadTexture(m_path, ilId, m_width, m_height);
	uint8_t* data = nullptr;
	eTextureImplDevIl::AssignPixels(data, m_width, m_height);

	// Load textures
	_genTexture();
	glBindTexture(GL_TEXTURE_2D, m_id);
	glTexImage2D(GL_TEXTURE_2D,
				0, 
				m_channels == 4 ? GL_RGBA : GL_RGB,
				m_width, 
				m_height, 
				0, 
				m_channels == 4 ? GL_RGBA : GL_RGB,
				GL_UNSIGNED_BYTE,
				(GLubyte*)data);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	if (m_use_mipmaps)
	{
		glGenerateMipmap(GL_TEXTURE_2D);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	}

	eTextureImplDevIl::DeleteImage(ilId);
	return true;
}

//-----------------------------------------------------------------------------------------------
uint8_t* Texture::getPixelBuffer(GLenum _target, GLenum _format, GLenum _type) const
{ 
	int sizeOfByte = _type == GL_FLOAT ? sizeof(float) : sizeof(unsigned char);
	int bytesToUsePerPixel = m_channels;
	int theSize = m_width * m_height * sizeOfByte * bytesToUsePerPixel * m_layers;
	uint8_t* imData = (uint8_t*)malloc(theSize);

	glBindTexture(_target, this->m_id);
	glGetTexImage(_target, 0, _format, _type, (void*)imData); //generic

	glBindTexture(_target, 0);
	return imData;
}

//-----------------------------------------------------------------------------------------------
bool Texture::saveToFile(const std::string &path, GLenum _target, GLenum _format, GLenum _type)
{
	uint8_t* imData = getPixelBuffer(_target, _format, _type);
	eTextureImplDevIl::SaveToFile(imData, path, m_width, m_height, m_layers, m_channels, _type); //rgb/rgba byte/float ?
	free(imData);
	return true;
}

//-----------------------------------------------------------------------------------------------
void Texture::freeTexture()
{
	//Delete texture
	if (m_id != 0)
	{
		if (indexes_in_use.find(m_id) != indexes_in_use.end())
		{
			std::cout << "free texture " << m_id << ": " << --textures_in_use << std::endl;
			indexes_in_use.erase(m_id);
			glDeleteTextures(1, &m_id);
			m_id = 0;
		}
		else
		{
			std::cout << "trying to free texture which was not generated by texture class" << std::endl;
		}
	}
	m_width = 0;
	m_height = 0;
}

//-----------------------------------------------------------------------------------------------
bool Texture::_loadTexture1x1(TColor color)
{
	GLubyte tex[4];
	switch (color)
	{
	case WHITE:
		tex[0]=255, tex[1] = 255, tex[2] = 255, tex[3] = 255;
		break;
	case BLACK:
		tex[0] = 0, tex[1] = 0, tex[2] = 0, tex[3] = 255;
		break;
	case BLUE:
		tex[0] = 128, tex[1] = 128, tex[2] = 255, tex[3] = 255;
		break;
	case PINK:
		tex[0] = 232, tex[1] = 100, tex[2] = 214, tex[3] = 255;
		break;
	case YELLOW:
		tex[0] = 255, tex[1] = 255, tex[2] = 0, tex[3] = 255;
		break;
	case GREY:
		tex[0] = 122, tex[1] = 122, tex[2] = 122, tex[3] = 255;
		break;
	}
	// Load textures
	_genTexture();
	glBindTexture(GL_TEXTURE_2D, m_id);

	m_width = 1;
	m_height = 1;
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, m_width, m_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, tex);
	m_channels = 4;

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glBindTexture(GL_TEXTURE_2D, 0);
	
	return true;
}

//-----------------------------------------------------------------------------------------------
bool Texture::loadCubemap(std::vector<std::string> faces)
{
  //unsigned char* image;
  _genTexture();
  glBindTexture(GL_TEXTURE_CUBE_MAP, m_id);
  for (GLuint i = 0; i < faces.size(); i++)
  {
    //	glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB, Width, Height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
    //Generate and set current image ID
    ILuint imgID = 0;
    ilGenImages(1, &imgID);
    ilBindImage(imgID);

    //Load image
    //ILboolean success = ilLoadImage( path.c_str() );
    ILboolean success = ilLoadImage((const wchar_t*)(faces[i].c_str)());
    int i0 = ilGetError();
    if (!success)
      std::cout << "error loading image" << std::endl;
    int i1 = IL_COULD_NOT_OPEN_FILE;
    int i2 = IL_ILLEGAL_OPERATION;
    int i3 = IL_INVALID_PARAM;

    //Image loaded successfully
    m_width = ilGetInteger(IL_IMAGE_WIDTH);
    m_height = ilGetInteger(IL_IMAGE_HEIGHT);
    auto pixmap = new BYTE[m_width * m_height * 3];
    ilCopyPixels(0, 0, 0, m_width, m_height, 1, IL_RGB, IL_UNSIGNED_BYTE, pixmap);

    //Convert image to RGBA
    success = ilConvertImage(IL_RGBA, IL_UNSIGNED_BYTE); // always converts rgb -> rgba
    if (!success)
      std::cout << "error converting image" << std::endl;
    // Load textures
    glBindTexture(GL_TEXTURE_2D, m_id);
    glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGBA, m_width, m_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, (GLuint*)ilGetData());
    //
    ilDeleteImages(1, &imgID);
		delete[] pixmap;
  }
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
  glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
  glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
  m_channels = 4;

  return true;
}

//----------------------------------------------------------------------------------------------------------
bool Texture::makeCubemap(size_t _size, bool _mipmap, GLenum _format, GLenum _internal_format, GLenum _type)
{
	if (_internal_format == GL_RGBA)
		m_channels = 4;
	else
		m_channels = 3;
	m_width = (int32_t)_size;
	m_height = (int32_t)_size;

	_genTexture();
	glBindTexture(GL_TEXTURE_CUBE_MAP, m_id);

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
	if(_mipmap)
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	else
		glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	int buffer_size = m_width * m_height * m_channels;

	for (GLuint i = 0; i < 6; ++i)
	{
		std::vector<float> xData(buffer_size, 0.2f + i * 0.3f); //for debug
		glBindTexture(GL_TEXTURE_2D, m_id);
		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, _internal_format, m_width, m_height, 0, _format, _type, &xData[0]);
	}
	if(_mipmap)
		glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

	glBindTexture(GL_TEXTURE_CUBE_MAP, 0);
	return true;
}

//-----------------------------------------------------------------------------------------------
bool Texture::makeDepthTexture()
{
	assert(m_height);
	assert(m_width);

	_genTexture();
	glBindTexture(GL_TEXTURE_2D, m_id);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, m_width, m_height, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE, GL_COMPARE_R_TO_TEXTURE);
	GLfloat borderColor[] = { 1.0,  1.0,  1.0,  1.0 };
	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_BORDER);

	return true;
}

//-----------------------------------------------------------------------------------------------
bool Texture::makeDepthTextureArray(int32_t _layers)
{
	assert(m_height);
	assert(m_width);
	m_layers = _layers;
	m_channels = 1;

	_genTexture();
	glBindTexture(GL_TEXTURE_2D_ARRAY, m_id);

	std::vector<float> xData(m_height* m_width* _layers, 0.2f); //for debug

	glTexImage3D(
		GL_TEXTURE_2D_ARRAY,
		0,
		GL_DEPTH_COMPONENT32F,
		m_width,
		m_height,
		_layers,
		0,
		GL_DEPTH_COMPONENT,
		GL_FLOAT,
		&xData[0]);

	glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
	glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);

	constexpr float bordercolor[] = { 0.0,  0.0,  0.0,  1.0 };
	glTexParameterfv(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BORDER_COLOR, bordercolor);

	return true;
}

//-----------------------------------------------------------------------------------------------
bool Texture::makeDepthCubeMap()
{
	assert(m_height);
	assert(m_width);

	_genTexture();
	glBindTexture(GL_TEXTURE_CUBE_MAP, m_id);
	for (unsigned int i = 0; i < 6; ++i)
		glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_DEPTH_COMPONENT,
			m_width, m_height, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);

	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

	return true;
}

//-----------------------------------------------------------------------------------------------
bool Texture::makeRandom1DTexture(unsigned int _size)
{
	glm::vec3* pRandomData = new glm::vec3[_size];

	for (unsigned int i = 0; i < _size; i++)
	{
		pRandomData[i].x = math::Random::RandomFloat(0.0f, 1.0f);
		pRandomData[i].y = math::Random::RandomFloat(0.0f, 1.0f);
		pRandomData[i].z = math::Random::RandomFloat(0.0f, 1.0f);
	}

	_genTexture();
	glBindTexture(GL_TEXTURE_1D, m_id);
	glTexImage1D(GL_TEXTURE_1D, 0, GL_RGB, _size, 0, GL_RGB, GL_FLOAT, pRandomData);//?
	glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);

	delete[] pRandomData;

	return true;
}

//-----------------------------------------------------------------------------------------------
bool Texture::makeImage(GLuint _width, GLuint _height)
{
	m_path = "";
	m_type = "";
	m_width = _width;
	m_height = _height;
	_genTexture();
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, m_id);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, m_width, m_height, 0, GL_RGBA, GL_FLOAT, NULL);

	glBindImageTexture(0, m_id, 0, GL_FALSE, 0, GL_READ_WRITE, GL_RGBA32F);
	return true;
}

//-----------------------------------------------------------------------------------------------
bool Texture::generatePerlin(GLuint _width, GLuint _height, bool periodic)
{
	this->m_width = _width;
	this->m_height = _height;

	float a = 1.0f;
	float b = 2.0f;

	float xFactor = 1.0f / (_width - 1);
	float yFactor = 1.0f / (_height - 1);

	this->m_channels = 4; //octaves

	GLubyte *data = new GLubyte[_width * _height * 4];
	for (uint32_t row = 0; row < _height; row++)
	{
		for (uint32_t col = 0; col < _width; col++)  //row?
		{
			float x = xFactor * col;
			float y = yFactor * row;
			float sum = 0.0f;
			float freq = a;
			float scale = b;
			for (int oct = 0; oct < m_channels; ++oct)
			{
				glm::vec2 p(x * freq, y * freq);
				float val = 0.0f;
				if(periodic)
					val = glm::perlin(p, glm::vec2(freq) ) / scale;
				else
					val = glm::perlin(p) / scale;

				sum += val;
				float result = (sum + 1.0f) / 2.0f;

				data[((row * _width + col) * 4) + oct] = (GLubyte)(result * 255.0f);
				freq *= 2.0f;
				scale *= b;
			}
		}
	}
	
	_genTexture();
	glBindTexture(GL_TEXTURE_2D, m_id);
	glTexStorage2D(GL_TEXTURE_2D, 1, GL_RGBA8, this->m_width, this->m_height);
	glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, this->m_width, this->m_height, GL_RGBA, GL_UNSIGNED_BYTE, (void*)data);
	
	delete[] data;
	return true;
}

//----------------------------------------------------------------------
bool Texture::loadHdr(const std::string& _path)
{
	stbi_set_flip_vertically_on_load(true);
	m_path = _path;
	float* data = stbi_loadf(_path.c_str(), &m_width, &m_height, &m_channels, 0);
	if (data)
	{
		_genTexture();
		glBindTexture(GL_TEXTURE_2D, m_id);
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, m_width, m_height, 0, GL_RGB, GL_FLOAT, data);

		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

		stbi_image_free(data);
		return true;
	}
	else
	{
		std::cout << "Failed to load HDR image." << std::endl;
		return false;
	}
}

//----------------------------------------------------------------------
bool Texture::loadTexture2DArray(std::vector<std::string> _paths, GLenum _format)
{
	m_path = "";
	m_type = "";
	m_width = 0;
	m_height = 0;
	if (_format == GL_RGBA)
		m_channels = 4;
	else
		m_channels = 1;

	GLsizei layers = (GLsizei)_paths.size();

	if (layers == 0)
		return false;

	glCreateTextures(GL_TEXTURE_2D_ARRAY, 1, &m_id);
	++textures_in_use;
	indexes_in_use.insert(m_id);

	uint32_t ilId;
	for (int layer = 0; layer < _paths.size(); ++layer)
	{
		eTextureImplDevIl::LoadTexture(_paths[layer], ilId, m_width, m_height); //rgb ? rgba
		if (layer == 0)
		{
			if(_format == GL_RGBA)
				glTextureStorage3D(m_id, 1, GL_RGBA8, m_width, m_height, layers); // after eTextureImplDevIl::LoadTexture assignes width an height
			else if(_format == GL_RED)
				glTextureStorage3D(m_id, 1, GL_R8, m_width, m_height, layers);
		}
		uint8_t* data = nullptr;
		eTextureImplDevIl::AssignPixels(data, m_width, m_height);
		glTextureSubImage3D(m_id, 0/*mipmap_level*/, 0/*offset.x*/, 0/*offset.y*/, layer/*offset.z*/, m_width, m_height, 1 /*layer*/, _format, GL_UNSIGNED_BYTE, data);
		eTextureImplDevIl::DeleteImage(ilId);

		glGenerateMipmap(m_id);
		glTextureParameteri(m_id, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTextureParameteri(m_id, GL_TEXTURE_WRAP_T, GL_REPEAT);
		glTextureParameteri(m_id, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTextureParameteri(m_id, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	}
	return true;
}

//----------------------------------------------------------------------
void Texture::_genTexture()
{
	glGenTextures(1, &m_id);
	if (m_id != GetDefaultTextureId())
	{
		std::cout << "gen texture " << m_id << std::endl;
		++textures_in_use;
		indexes_in_use.insert(m_id);
	}
}
